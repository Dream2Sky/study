## Redis 为什么用单线程？

首先redis的单线程不是说单线程在运行的时候只有一个线程。而是redis的网络IO处理和键值对的存取是由一个线程来完成。其他功能由其他线程来完成。

原因是为了避免多线程的开销。

### 多线程的开销

多线程在争夺共享资源的时候需要有保护机制来保护数据的安全。比如加锁。并且需要精细的设计才能很好的控制共享资源在被访问的时候不会使得其他线程等待的时间过长。

同时采用多线程开发的时候往往会引入同步原语来保护共享资源的并发访问。也会降低系统代码的可维护性。

**所以为了避免以上问题，redis就直接使用单线程。**

## 单线程的redis为什么快

1.采用合理高效的数据结构，使得在存取数据方面性能优异。比如采用hash和跳表等数据结构
2.在处理网路IO时，采用IO多路复用的机制来实现高吞吐率

### 基于多路复用的高性能 I/O 模型

1. 基于linux `select/epoll `
2. 内核可同时监听多个监听套接字和 多个已连接套接字 
3. 一旦内核监听到套接字上有数据返回，立刻交给redis线程处理数据

**前两步是IO多路复用机制。**
![image](https://static001.geekbang.org/resource/image/00/ea/00ff790d4f6225aaeeebba34a71d8bea.jpg)

为了能在请求到达时通知到redis的线程，`select/epoll`提供了基于事件的回调机制，即针对不同的事件，调用不同的处理函数。

在`select/epoll`中，一旦监听到有请求到达时，就会触发相应的事件，这些事件会被放到一个**事件队列**。而redis就只对这个**事件队列**进行处理。

## redis单线程模型存在哪些性能瓶颈

1. 任意一个请求在server中一旦发生耗时，都会影响整个server的性能，也就是说后面的请求都要等前面这个耗时请求处理完成，自己才能被处理到。耗时的操作包括以下几种:

    - **操作`bigkey`**：写入一个`bigkey`在分配内存时需要消耗更多的时间，同样，删除`bigkey`释放内存同样会产生耗时；
    - **使用复杂度过高的命令**：例如`SORT/SUNION/ZUNIONSTORE`，或者`O(N)命令`，但是N很大，例如`lrange key 0 -1`一次查询全量数据；
    - **大量key集中过期**：Redis的==过期机制是在主线程中执行的==，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长；
    - **淘汰策略**：==淘汰策略是在主线程执行的==，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会造成耗时变长；
    - **AOF刷盘开启always机制**：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能；
    - **主从全量同步生成RDB**：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久；

2. 并发量非常大时，单线程读写客户端IO数据存在性能瓶颈，**虽然采用IO多路复用机制，但是读写客户端数据依旧是同步IO**，只能单线程依次读取客户端的数据，==无法利用到CPU多核(**可以说是单线程模型的缺陷**)==。


#### 解决方案
针对问题1，一方面需要业务人员去规避，一方面Redis在`4.0`推出了`lazy-free`机制，把`bigkey`释放内存的耗时操作放在了异步线程中执行，降低对主线程的影响。

针对问题2，**Redis在6.0推出了多线程**，可以在高并发场景下利用**CPU多核多线程读写客户端数据**，进一步提升server性能，当然，只是针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的。