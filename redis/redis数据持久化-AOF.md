## AOF日志如何实现

一般熟悉的数据库采用的都是**写前日志**：`WAL`(write ahead log)。例如`MySQL`

不过redis采用的**写后日志**，即==先执行命令，然后把数据写入内存，然后再写日志==

![image](https://static001.geekbang.org/resource/image/40/1f/407f2686083afc37351cfd9107319a1f.jpg)


### AOF日志的内容

传统数据的日志记录的是操作后的数据，比如`MySQL`的`redo log`。

redis的日志记录的是操作命令

![image](https://static001.geekbang.org/resource/image/4d/9f/4d120bee623642e75fdf1c0700623a9f.jpg)

### AOF的好处

==**在执行命令之后才写日志，不会阻塞当前命令的执行**==

### AOF潜在的两个风险

1. 在执行命令之后就宕机了，还没来得及写日志到磁盘，那么在恢复数据的时候就没有日志恢复
2. 不会阻塞当前命令执行，但是会阻塞后面的操作。

## AOF的三种写回策略

`appendfsync`的配置，有三种可选项，分别是:
- Always (同步回写)：每执行完一个命令就马上同步写日志到磁盘
- Everysec (每秒回写)：每个命令执行完之后，只是把命令写道内存缓冲区中，然后每个一秒将缓冲区中的内容写回到磁盘
- No (操作系统控制回写时机)：每次命令执行完后，只是把日志写到内存缓冲区中，至于写回到磁盘的时机由操作系统决定

![image](https://static001.geekbang.org/resource/image/72/f8/72f547f18dbac788c7d11yy167d7ebf8.jpg)

## AOF的重写机制

AOF写的是文件，时间长了之后日志文件会变得巨大，同时在一般的文件系统中，不允许有过大的文件，或者是限定了文件的大小。**也就是说文件系统对文件大小的限制**。

**同时过大的日志文件在读写的时候也会带来性能问题**。

为了解决上述问题，redis引进AOF的重写机制。

简单的说，重写机制就是根据数据库的现状，即当前数据状态，重新创建一个新的日志文件，然后扫描一遍数据库，将现有的数据转化为命令写入到日志文件中。

![image](https://static001.geekbang.org/resource/image/65/08/6528c699fdcf40b404af57040bb8d208.jpg)


***==AOF的重写机制不会带来主线程的阻塞。==***

重写日志的时候会redis会开启一个子进程来执行，即`bgrewriteaof`。


### 重写的过程

1. 一个拷贝
    主线程fork出后台的bgrewriteaof子进程之后，会复制主进程的内存页表，共享主进程的内存数据。这样就可以做到在不影响主线程的情况下，重写日志。
2. 两处日志
    一处是主线程正在使用的AOF日志，一处是bgrewriteaof使用的AOF日志。因为主线程并没有阻塞，可以继续接受新的修改数据的请求，所以，依然可以记录新的修改日志，所以为了保证重写的日志里面包含最新的修改操作，需要在重写的AOF日志的缓冲区里同时也写入新的操作日志。

![image](https://static001.geekbang.org/resource/image/6b/e8/6b054eb1aed0734bd81ddab9a31d0be8.jpg)